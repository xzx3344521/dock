#!/bin/bash

# 修复版一键网络检测脚本
set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# 日志函数
log() { echo -e "${BLUE}[$(date '+%H:%M:%S')]${NC} $1"; }
success() { echo -e "${GREEN}✓${NC} $1"; }
warning() { echo -e "${YELLOW}⚠${NC} $1"; }
error() { echo -e "${RED}✗${NC} $1"; }
info() { echo -e "${CYAN}ℹ${NC} $1"; }

# 安装依赖工具（修复版）
install_dependencies() {
    log "检查并安装必要的网络工具..."
    
    local tools_missing=()
    
    # 检查工具是否存在
    if ! command -v nc &> /dev/null && ! command -v netcat &> /dev/null; then
        tools_missing+=("netcat-openbsd")
    fi
    if ! command -v telnet &> /dev/null; then
        tools_missing+=("telnet")
    fi
    if ! command -v nmap &> /dev/null; then
        tools_missing+=("nmap")
    fi
    if ! command -v traceroute &> /dev/null; then
        tools_missing+=("traceroute")
    fi
    if ! command -v curl &> /dev/null; then
        tools_missing+=("curl")
    fi
    
    if [ ${#tools_missing[@]} -eq 0 ]; then
        success "所有必要工具已安装"
        return 0
    fi
    
    info "需要安装的工具: ${tools_missing[*]}"
    
    # Debian/Ubuntu系统
    if command -v apt &> /dev/null; then
        apt update
        if apt install -y "${tools_missing[@]}"; then
            success "工具安装完成"
        else
            # 如果批量安装失败，尝试逐个安装
            for tool in "${tools_missing[@]}"; do
                if apt install -y "$tool"; then
                    success "安装 $tool 成功"
                else
                    warning "安装 $tool 失败，跳过"
                fi
            done
        fi
    # CentOS/RHEL系统
    elif command -v yum &> /dev/null; then
        yum install -y "${tools_missing[@]}"
    elif command -v dnf &> /dev/null; then
        dnf install -y "${tools_missing[@]}"
    else
        warning "未知包管理器，请手动安装工具"
        return 1
    fi
}

# 端口检测函数
check_port() {
    local host=$1
    local port=$2
    local timeout=${3:-5}
    
    log "检测 $host:$port (超时: ${timeout}s)"
    
    local methods=0
    local success_methods=0
    
    # 方法1: nc (netcat)
    if command -v nc &> /dev/null; then
        ((methods++))
        if timeout "$timeout" nc -z -w "$timeout" "$host" "$port" &> /dev/null; then
            success "nc检测: 端口 $port 开放"
            ((success_methods++))
        else
            error "nc检测: 端口 $port 关闭"
        fi
    fi
    
    # 方法2: /dev/tcp (bash内置)
    ((methods++))
    if timeout "$timeout" bash -c "echo > /dev/tcp/$host/$port" &> /dev/null; then
        success "bash检测: 端口 $port 开放"
        ((success_methods++))
    else
        error "bash检测: 端口 $port 关闭"
    fi
    
    # 方法3: telnet
    if command -v telnet &> /dev/null; then
        ((methods++))
        if echo "quit" | timeout "$timeout" telnet "$host" "$port" 2>&1 | grep -q "Connected\|Escape character"; then
            success "telnet检测: 端口 $port 开放"
            ((success_methods++))
        else
            error "telnet检测: 端口 $port 关闭"
        fi
    fi
    
    # 方法4: nmap
    if command -v nmap &> /dev/null; then
        ((methods++))
        if nmap -p "$port" "$host" 2>&1 | grep -q "$port/tcp open"; then
            success "nmap检测: 端口 $port 开放"
            ((success_methods++))
        else
            error "nmap检测: 端口 $port 关闭"
        fi
    fi
    
    # 汇总结果
    if [ $success_methods -gt 0 ]; then
        success "端口检测结果: $success_methods/$methods 种方法确认端口开放"
        return 0
    else
        error "端口检测结果: 所有 $methods 种方法确认端口关闭"
        return 1
    fi
}

# HTTP服务检测
check_http_service() {
    local host=$1
    local port=$2
    
    log "检测HTTP服务..."
    
    # 尝试HTTP
    if curl -s -I --connect-timeout 5 "http://$host:$port/" &> /dev/null; then
        success "HTTP服务正常 (http://$host:$port)"
        # 获取HTTP头信息
        echo "HTTP响应头:"
        curl -s -I --connect-timeout 3 "http://$host:$port/" | head -10
        return 0
    fi
    
    # 尝试HTTPS
    if curl -s -I --connect-timeout 5 "https://$host:$port/" &> /dev/null; then
        success "HTTPS服务正常 (https://$host:$port)"
        echo "HTTPS响应头:"
        curl -s -I --connect-timeout 3 "https://$host:$port/" | head -10
        return 0
    fi
    
    # 尝试简单的TCP连接测试
    if timeout 3 bash -c "echo -e 'GET / HTTP/1.0\r\n\r\n' | nc $host $port" 2>/dev/null | head -1 | grep -q "HTTP"; then
        success "HTTP服务响应 (手动测试)"
        return 0
    fi
    
    error "HTTP/HTTPS服务无法访问"
    return 1
}

# 路由跟踪
trace_route() {
    local host=$1
    
    log "执行路由跟踪到 $host ..."
    
    if command -v traceroute &> /dev/null; then
        traceroute -w 1 -q 1 -m 10 "$host" 2>/dev/null | head -15
    elif command -v tracepath &> /dev/null; then
        tracepath "$host" 2>/dev/null | head -10
    else
        warning "未找到路由跟踪工具，跳过"
    fi
}

# 批量端口扫描
scan_common_ports() {
    local host=$1
    
    log "快速扫描常用端口..."
    local common_ports=(21 22 23 53 80 110 143 443 465 587 993 995 1433 1521 3306 3389 5432 5900 6379 27017 21114)
    local open_ports=()
    
    for port in "${common_ports[@]}"; do
        if timeout 1 bash -c "echo > /dev/tcp/$host/$port" 2>/dev/null; then
            open_ports+=("$port")
            success "端口 $port 开放"
        fi
    done
    
    if [ ${#open_ports[@]} -gt 0 ]; then
        success "发现 ${#open_ports[@]} 个开放端口: ${open_ports[*]}"
    else
        warning "未发现常用开放端口"
    fi
}

# 主检测函数
main_check() {
    local target=$1
    local port=$2
    local timeout=$3
    
    echo -e "${PURPLE}"
    echo "=========================================="
    echo "          网络端口检测报告"
    echo "=========================================="
    echo -e "${NC}"
    
    log "目标: $target"
    [ -n "$port" ] && log "端口: $port"
    log "时间: $(date)"
    echo
    
    # 安装依赖
    install_dependencies
    echo
    
    # 基础连通性检查
    log "基础网络连通性检查..."
    if ping -c 2 -W 2 "$target" &> /dev/null; then
        success "主机网络可达"
    else
        error "主机网络不可达"
    fi
    echo
    
    # 路由跟踪
    trace_route "$target"
    echo
    
    # 批量端口扫描
    scan_common_ports "$target"
    echo
    
    # 如果指定了端口，进行详细检测
    if [ -n "$port" ]; then
        log "开始详细端口检测..."
        check_port "$target" "$port" "$timeout"
        echo
        
        # HTTP服务检测（如果是Web端口）
        if [[ "$port" =~ ^(80|443|8080|8443)$ ]]; then
            check_http_service "$target" "$port"
        fi
    fi
    
    echo
    success "检测完成!"
    info "报告生成时间: $(date)"
}

# 使用说明
show_usage() {
    echo "用法: $0 [目标地址] [端口] [超时时间]"
    echo
    echo "示例:"
    echo "  $0 27.194.150.137 21114      # 检测指定IP和端口"
    echo "  $0 google.com 80 10          # 检测域名端口，超时10秒"
    echo "  $0 192.168.1.1               # 只扫描常用端口"
    echo
    echo "注意:"
    echo "  - 脚本会自动安装必要的检测工具"
    echo "  - 超时时间默认5秒"
}

# 参数解析
if [ $# -eq 0 ]; then
    info "请输入要检测的目标地址:"
    read -r target_input
    
    # 解析输入（支持 host:port 格式）
    if [[ "$target_input" =~ : ]]; then
        target_host=$(echo "$target_input" | cut -d: -f1)
        target_port=$(echo "$target_input" | cut -d: -f2)
        info "请输入超时时间(默认5秒):"
        read -r timeout_input
        timeout=${timeout_input:-5}
    else
        target_host="$target_input"
        info "请输入要检测的端口(直接回车只扫描常用端口):"
        read -r target_port
        if [ -n "$target_port" ]; then
            info "请输入超时时间(默认5秒):"
            read -r timeout_input
            timeout=${timeout_input:-5}
        fi
    fi
else
    target_host=$1
    target_port=$2
    timeout=${3:-5}
fi

# 运行检测
main_check "$target_host" "$target_port" "$timeout"
