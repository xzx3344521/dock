# 停止所有可能的监控进程
pkill -f "cmd_monitor" 2>/dev/null
rm -f /tmp/cmd_monitor.pid
rm -f /tmp/cmd_monitor.last_cmd

# 创建监控目录
mkdir -p /root/monitor
mkdir -p /root/command_logs

# 创建新的监控脚本
cat > /root/monitor/monitor.sh << 'EOF'
#!/bin/bash

SCRIPT_PATH="/root/monitor/monitor.sh"
LOG_DIR="/root/command_logs"
PID_FILE="/tmp/cmd_monitor.pid"

# 获取客户端IP
get_client_ip() {
    local ip="unknown"
    [ -n "$SSH_CLIENT" ] && ip=$(echo "$SSH_CLIENT" | awk '{print $1}')
    [ "$ip" = "unknown" ] && [ -n "$SSH_CONNECTION" ] && ip=$(echo "$SSH_CONNECTION" | awk '{print $1}')
    echo "$ip"
}

# 检查是否运行中
is_running() {
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE" 2>/dev/null)
        if ps -p "$pid" >/dev/null 2>&1; then
            return 0
        else
            rm -f "$PID_FILE"
        fi
    fi
    return 1
}

# to命令处理
if [ "$1" = "to" ]; then
    if is_running; then
        echo "🔄 切换到前台显示模式..."
        # 前台显示模式
        echo "🔍 实时监控显示中..."
        echo "💡 输入 'exit' 返回后台模式"
        echo "================================"
        
        # 显示最近记录
        if [ -f "$LOG_DIR/monitor.log" ]; then
            echo "最近记录:"
            tail -5 "$LOG_DIR/monitor.log" | while read line; do
                echo "  📌 $line"
            done
            echo "------------------------"
        fi
        
        # 实时显示新命令
        while true; do
            # 检查退出命令
            if read -t 1 -n 4 input 2>/dev
