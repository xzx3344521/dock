# åœæ­¢æ‰€æœ‰ç›‘æ§è¿›ç¨‹
/root/monitor/cmd_monitor.sh stop
pkill -f "cmd_monitor.sh" 2>/dev/null
rm -f /tmp/cmd_monitor.pid

# åˆ›å»ºä¿®å¤ç‰ˆçš„ç›‘æ§è„šæœ¬
cat > /root/monitor/cmd_monitor_fixed.sh << 'EOF'
#!/bin/bash

INSTALL_DIR="/root/monitor"
SCRIPT_PATH="$INSTALL_DIR/cmd_monitor_fixed.sh"
LOG_DIR="/root/command_logs"
PID_FILE="/tmp/cmd_monitor.pid"
LOCK_FILE="/tmp/cmd_monitor.lock"

# è·å–å®¢æˆ·ç«¯IPå’Œåœ°ç†ä½ç½®
get_client_ip() {
    local ip="unknown"
    [ -n "$SSH_CLIENT" ] && ip=$(echo "$SSH_CLIENT" | awk '{print $1}')
    [ "$ip" = "unknown" ] && [ -n "$SSH_CONNECTION" ] && ip=$(echo "$SSH_CONNECTION" | awk '{print $1}')
    echo "$ip"
}

get_ip_location() {
    local ip="$1"
    [ "$ip" = "unknown" ] && echo "unknown" && return
    [ "$ip" = "127.0.0.1" ] && echo "localhost" && return
    [ "$ip" = "::1" ] && echo "localhost" && return
    
    # ä½¿ç”¨ipapi.coè·å–åœ°ç†ä½ç½®ä¿¡æ¯
    location=$(curl -s -m 2 "http://ipapi.co/$ip/country_name/" 2>/dev/null || echo "unknown")
    city=$(curl -s -m 2 "http://ipapi.co/$ip/city/" 2>/dev/null || echo "")
    
    if [ "$location" != "unknown" ] && [ -n "$city" ] && [ "$city" != "unknown" ]; then
        echo "$city, $location"
    elif [ "$location" != "unknown" ]; then
        echo "$location"
    else
        echo "unknown"
    fi
}

# æ£€æŸ¥æ˜¯å¦å·²ç»è¿è¡Œ
is_running() {
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE" 2>/dev/null)
        if ps -p "$pid" >/dev/null 2>&1; then
            return 0
        else
            rm -f "$PID_FILE"
        fi
    fi
    return 1
}

# è·å–é”
acquire_lock() {
    exec 200>"$LOCK_FILE"
    flock -n 200 && return 0
    return 1
}

# é‡Šæ”¾é”
release_lock() {
    flock -u 200
    rm -f "$LOCK_FILE"
}

# æ£€æŸ¥toå‘½ä»¤
if [ "$1" = "to" ]; then
    if is_running; then
        echo "åˆ‡æ¢åˆ°å‰å°æ˜¾ç¤ºæ¨¡å¼..."
        # ä¸åœæ­¢åå°è¿›ç¨‹ï¼Œåªæ˜¯å¯åŠ¨å‰å°æ˜¾ç¤º
        exec "$SCRIPT_PATH" display
    else
        echo "å¯åŠ¨åå°ç›‘æ§+å‰å°æ˜¾ç¤ºæ¨¡å¼..."
        exec "$SCRIPT_PATH" both
    fi
    exit 0
fi

case "$1" in
    both|start)
        if ! acquire_lock; then
            echo "ç›‘æ§å·²ç»åœ¨è¿è¡Œä¸­"
            exit 1
        fi
        
        echo "å¯åŠ¨åå°ç›‘æ§+å‰å°æ˜¾ç¤ºæ¨¡å¼..."
        
        # è®¾ç½®å®æ—¶history
        for user_dir in /home/* /root; do
            [ -d "$user_dir" ] || continue
            bashrc="$user_dir/.bashrc"
            [ -f "$bashrc" ] || continue
            if ! grep -q "PROMPT_COMMAND.*history" "$bashrc" 2>/dev/null; then
                echo 'export PROMPT_COMMAND="history -a; history -c; history -r"' >> "$bashrc"
                echo "å·²ä¸º $user_dir è®¾ç½®å®æ—¶history"
            fi
        done
        
        # å¯åŠ¨åå°ç›‘æ§
        (
            echo "=== åå°ç›‘æ§å¯åŠ¨: $(date) ===" >> "$LOG_DIR/monitor.log"
            declare -A last_sizes
            
            # åˆå§‹åŒ–æ–‡ä»¶å¤§å°
            for user_dir in /home/* /root; do
                [ -d "$user_dir" ] || continue
                user=$(basename "$user_dir")
                history_file="$user_dir/.bash_history"
                [ -f "$history_file" ] && last_sizes["$user"]=$(stat -c%s "$history_file" 2>/dev/null || echo 0)
            done
            
            while true; do
                for user_dir in /home/* /root; do
                    [ -d "$user_dir" ] || continue
                    user=$(basename "$user_dir")
                    history_file="$user_dir/.bash_history"
                    [ -f "$history_file" ] || continue
                    
                    current_size=$(stat -c%s "$history_file" 2>/dev/null || echo 0)
                    last_size=${last_sizes["$user"]:-0}
                    
                    if [ "$current_size" -gt "$last_size" ]; then
                        new_cmd=$(tail -n 1 "$history_file" 2>/dev/null | sed 's/^[ \t]*//;s/[ \t]*$//')
                        if [ -n "$new_cmd" ] && [ ${#new_cmd} -gt 1 ]; then
                            # è¿‡æ»¤ç®€å•å‘½ä»¤
                            case "$new_cmd" in
                                ls|cd|pwd|ll|history|exit|clear|to|"."|"..")
                                    continue
                                    ;;
                                *)
                                    client_ip=$(get_client_ip)
                                    location=$(get_ip_location "$client_ip")
                                    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
                                    log_entry="[$timestamp] ç”¨æˆ·:$user | å‘½ä»¤:$new_cmd | æ¥æºIP:$client_ip | ä½ç½®:$location"
                                    echo "$log_entry" >> "$LOG_DIR/monitor.log"
                                    # åŒæ—¶è¾“å‡ºåˆ°å‰å°ï¼ˆå¦‚æœæœ‰äººåœ¨çœ‹ï¼‰
                                    echo "$log_entry" > /tmp/cmd_monitor.last_cmd
                                    ;;
                            esac
                        fi
                        last_sizes["$user"]=$current_size
                    fi
                done
                sleep 2
            done
        ) &
        
        echo $! > "$PID_FILE"
        release_lock
        
        echo "âœ… åå°ç›‘æ§å·²å¯åŠ¨ (PID: $!)"
        echo "ğŸ“ æ—¥å¿—æ–‡ä»¶: $LOG_DIR/monitor.log"
        
        # å¯åŠ¨å‰å°æ˜¾ç¤º
        echo "ğŸ” å¯åŠ¨å‰å°æ˜¾ç¤º..."
        exec "$SCRIPT_PATH" display
        ;;
        
    display|foreground)
        echo "ğŸ” å‰å°æ˜¾ç¤ºæ¨¡å¼å¯åŠ¨..."
        echo "ğŸ’¡ åå°ç›‘æ§æŒç»­è¿è¡Œä¸­"
        echo "ğŸ’¡ è¾“å…¥ 'to' åˆ‡æ¢åˆ°çº¯åå°æ¨¡å¼"
        echo "â¹ï¸  æŒ‰ Ctrl+C åœæ­¢æ˜¾ç¤ºï¼ˆåå°ç»§ç»­è¿è¡Œï¼‰"
        echo "================================"
        
        # æ˜¾ç¤ºæœ€åå‡ æ¡è®°å½•
        if [ -f "$LOG_DIR/monitor.log" ]; then
            echo "æœ€è¿‘è®°å½•:"
            tail -5 "$LOG_DIR/monitor.log" | while read line; do
                echo "  ğŸ“Œ $line"
            done
            echo "------------------------"
        fi
        
        # è®¾ç½®ä¿¡å·å¤„ç†
        trap 'echo -e "\nğŸ›‘ åœæ­¢å‰å°æ˜¾ç¤ºï¼ˆåå°ç›‘æ§ç»§ç»­è¿è¡Œï¼‰"; exit 0' INT TERM
        
        # å®æ—¶æ˜¾ç¤ºæ–°å‘½ä»¤
        while true; do
            # æ£€æµ‹toå‘½ä»¤è¾“å…¥
            if read -t 1 -n 2 input 2>/dev/null; then
                if [ "$input" = "to" ]; then
                    echo "ğŸ”„ åˆ‡æ¢åˆ°çº¯åå°æ¨¡å¼..."
                    echo "âœ… åå°ç›‘æ§ç»§ç»­è¿è¡Œä¸­"
                    echo "ğŸ“ æŸ¥çœ‹æ—¥å¿—: tail -f $LOG_DIR/monitor.log"
                    exit 0
                fi
            fi
            
            # æ˜¾ç¤ºæ–°å‘½ä»¤
            if [ -f /tmp/cmd_monitor.last_cmd ]; then
                cat /tmp/cmd_monitor.last_cmd
                rm -f /tmp/cmd_monitor.last_cmd
            fi
        done
        ;;
        
    background)
        if ! acquire_lock; then
            echo "ç›‘æ§å·²ç»åœ¨è¿è¡Œä¸­"
            exit 1
        fi
        
        # åªå¯åŠ¨åå°ï¼Œä¸æ˜¾ç¤ºå‰å°
        echo "å¯åŠ¨çº¯åå°ç›‘æ§æ¨¡å¼..."
        
        # è®¾ç½®å®æ—¶history
        for user_dir in /home/* /root; do
            [ -d "$user_dir" ] || continue
            bashrc="$user_dir/.bashrc"
            [ -f "$bashrc" ] || continue
            if ! grep -q "PROMPT_COMMAND.*history" "$bashrc" 2>/dev/null; then
                echo 'export PROMPT_COMMAND="history -a; history -c; history -r"' >> "$bashrc"
            fi
        done
        
        # å¯åŠ¨åå°ç›‘æ§
        (
            echo "=== åå°ç›‘æ§å¯åŠ¨: $(date) ===" >> "$LOG_DIR/monitor.log"
            declare -A last_sizes
            
            # åˆå§‹åŒ–æ–‡ä»¶å¤§å°
            for user_dir in /home/* /root; do
                [ -d "$user_dir" ] || continue
                user=$(basename "$user_dir")
                history_file="$user_dir/.bash_history"
                [ -f "$history_file" ] && last_sizes["$user"]=$(stat -c%s "$history_file" 2>/dev/null || echo 0)
            done
            
            while true; do
                for user_dir in /home/* /root; do
                    [ -d "$user_dir" ] || continue
                    user=$(basename "$user_dir")
                    history_file="$user_dir/.bash_history"
                    [ -f "$history_file" ] || continue
                    
                    current_size=$(stat -c%s "$history_file" 2>/dev/null || echo 0)
                    last_size=${last_sizes["$user"]:-0}
                    
                    if [ "$current_size" -gt "$last_size" ]; then
                        new_cmd=$(tail -n 1 "$history_file" 2>/dev/null | sed 's/^[ \t]*//;s/[ \t]*$//')
                        if [ -n "$new_cmd" ] && [ ${#new_cmd} -gt 1 ]; then
                            case "$new_cmd" in
                                ls|cd|pwd|ll|history|exit|clear|to|"."|"..")
                                    continue
                                    ;;
                                *)
                                    client_ip=$(get_client_ip)
                                    location=$(get_ip_location "$client_ip")
                                    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
                                    log_entry="[$timestamp] ç”¨æˆ·:$user | å‘½ä»¤:$new_cmd | æ¥æºIP:$client_ip | ä½ç½®:$location"
                                    echo "$log_entry" >> "$LOG_DIR/monitor.log"
                                    ;;
                            esac
                        fi
                        last_sizes["$user"]=$current_size
                    fi
                done
                sleep 2
            done
        ) &
        
        echo $! > "$PID_FILE"
        release_lock
        
        echo "âœ… çº¯åå°ç›‘æ§å·²å¯åŠ¨ (PID: $!)"
        echo "ğŸ“ æ—¥å¿—æ–‡ä»¶: $LOG_DIR/monitor.log"
        echo "ğŸ” æŸ¥çœ‹å®æ—¶æ—¥å¿—: tail -f $LOG_DIR/monitor.log"
        ;;
        
    stop)
        if [ -f "$PID_FILE" ]; then
            pid=$(cat "$PID_FILE")
            if ps -p "$pid" >/dev/null 2>&1; then
                kill "$pid" 2>/dev/null
                rm -f "$PID_FILE"
                rm -f "$LOCK_FILE"
                rm -f /tmp/cmd_monitor.last_cmd
                echo "âœ… ç›‘æ§å·²åœæ­¢ (PID: $pid)"
            else
                rm -f "$PID_FILE"
                rm -f "$LOCK_FILE"
                echo "âš ï¸  ç›‘æ§è¿›ç¨‹ä¸å­˜åœ¨ï¼Œå·²æ¸…ç†"
            fi
        else
            echo "â„¹ï¸  ç›‘æ§æœªè¿è¡Œ"
        fi
        ;;
        
    status)
        if is_running; then
            pid=$(cat "$PID_FILE")
            echo "âœ… ç›‘æ§è¿è¡Œä¸­ (PID: $pid)"
            echo "ğŸ“ æ—¥å¿—æ–‡ä»¶: $LOG_DIR/monitor.log"
            echo "ğŸ“Š æ—¥å¿—è¡Œæ•°: $(wc -l < "$LOG_DIR/monitor.log" 2>/dev/null || echo 0)"
        else
            echo "âŒ ç›‘æ§æœªè¿è¡Œ"
        fi
        ;;
        
    install)
        # åˆ›å»ºæ—¥å¿—ç›®å½•
        mkdir -p "$LOG_DIR"
        
        # è®¾ç½®å¼€æœºè‡ªå¯åŠ¨ï¼ˆä½¿ç”¨bothæ¨¡å¼ï¼‰
        echo "ğŸ”§ è®¾ç½®å¼€æœºè‡ªå¯åŠ¨..."
        (crontab -l 2>/dev/null | grep -v "$SCRIPT_PATH"; echo "@reboot $SCRIPT_PATH background >/dev/null 2>&1") | crontab -
        
        # è®¾ç½®toå‘½ä»¤åˆ«å
        echo "ğŸ”§ è®¾ç½®å‘½ä»¤åˆ«å..."
        for user_dir in /home/* /root; do
            [ -d "$user_dir" ] || continue
            bashrc="$user_dir/.bashrc"
            [ -f "$bashrc" ] || continue
            if ! grep -q "alias to=" "$bashrc" 2>/dev/null; then
                echo "alias to='$SCRIPT_PATH to'" >> "$bashrc"
                echo "âœ… å·²ä¸º $user_dir è®¾ç½®åˆ«å"
            fi
        done
        
        echo ""
        echo "ğŸ‰ å®‰è£…å®Œæˆ!"
        echo "========================"
        echo "ç«‹å³ä½¿ç”¨:"
        echo "  to              - å¯åŠ¨åå°+å‰å°æ˜¾ç¤ºæ¨¡å¼"
        echo "  $SCRIPT_PATH both       - åå°+å‰å°æ˜¾ç¤ºæ¨¡å¼"
        echo "  $SCRIPT_PATH background - çº¯åå°æ¨¡å¼"
        echo "  $SCRIPT_PATH display    - ä»…å‰å°æ˜¾ç¤º"
        echo "  $SCRIPT_PATH stop       - åœæ­¢ç›‘æ§"
        echo "  $SCRIPT_PATH status     - æŸ¥çœ‹çŠ¶æ€"
        echo ""
        echo "è¯·è¿è¡Œ: source ~/.bashrc"
        ;;
        
    logs)
        if [ -f "$LOG_DIR/monitor.log" ]; then
            tail -20 "$LOG_DIR/monitor.log"
        else
            echo "æ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨: $LOG_DIR/monitor.log"
        fi
        ;;
        
    *)
        echo "å‘½ä»¤ç›‘æ§ç³»ç»Ÿ (å¢å¼ºç‰ˆ)"
        echo "========================"
        echo "ä½¿ç”¨æ–¹æ³•: $0 {both|background|display|stop|status|install|logs|to}"
        echo ""
        echo "æ¨¡å¼è¯´æ˜:"
        echo "  both       - åå°ç›‘æ§+å‰å°å®æ—¶æ˜¾ç¤º"
        echo "  background - çº¯åå°ç›‘æ§æ¨¡å¼"
        echo "  display    - ä»…å‰å°æ˜¾ç¤ºï¼ˆåå°éœ€è¿è¡Œï¼‰"
        echo "  to         - æ™ºèƒ½åˆ‡æ¢æ¨¡å¼"
        echo ""
        echo "å®‰è£…åç›´æ¥ä½¿ç”¨ 'to' å‘½ä»¤"
        ;;
esac
EOF

chmod +x /root/monitor/cmd_monitor_fixed.sh

# æ›´æ–°åˆ«åæŒ‡å‘æ–°è„šæœ¬
sed -i 's|alias to=.*|alias to="/root/monitor/cmd_monitor_fixed.sh to"|' ~/.bashrc

# æ›´æ–°crontabæŒ‡å‘æ–°è„šæœ¬
(crontab -l 2>/dev/null | grep -v "cmd_monitor" | grep -v "monitor") | crontab -
(crontab -l 2>/dev/null; echo "@reboot /bin/bash /root/monitor/cmd_monitor_fixed.sh background >/dev/null 2>&1") | crontab -

# é‡æ–°åŠ è½½é…ç½®
source ~/.bashrc

echo "ä¿®å¤å®Œæˆï¼ç°åœ¨æµ‹è¯•æ–°ç‰ˆæœ¬ï¼š"
echo "to  # å¯åŠ¨åå°+å‰å°æ˜¾ç¤ºæ¨¡å¼"
